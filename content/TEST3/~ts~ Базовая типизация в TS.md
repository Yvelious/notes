---
tags:
  - ts
order: 7
section: Basic
symlinkchapter: TEST3
symlink:
idnote: 0909
---

### Notes
-----
**Типы:**
Number
String
Boolean
Nothing (undefined, null)
literals
к примеур это переменные `const`
universal
let m:any=1



При создании переменных, TS проставляет типы автоматом, поэтому так прописывать не надо

`let tt:string = "hello"`
Typescript и так понимает что это число.
Плюс если я захочу переопределить переменную и вписать туда число, то  TS выдаст мне ошибку скажет что число это не тот тип который закреплен за переменной.

`tt = 1` будет ошибка.


#### Про функции

Вот к пример как проставлять типы для аргументов в функции, а также для редурна.
![[Pasted image 20230627000329.png]]


Функция которая не фига не возвращает без ретерна, нужно поставить  `:void`
![[Pasted image 20230627000725.png]]

Пример если в функции надо указать что один из параметров необязательный, ставим `?` 
`userId?: string` означает что не только строкой может быть данный аргумент, но и undefined.
![[Pasted image 20230627001549.png]]


#### Объекты
Для описание объекта используется `interface`

```json
interface Car {
	wheels: number;
	lights: boolean;
	brand?: string;
}
```
N.B.
Обычно пишется с большой буквы название интерфейс.  Обычно количество ключей объявленный в интерфейсе должно соответствовать и в том объекту к которому мы прикрепляем интерфейс. Но можно сделать некоторые ключи и опциональные добавив `?`  к названию ключ. Плюс не сможем потом в объект добавить новое поле, если оно не было обозначено в интерфейсе.

Если нам нужно все таки имеет возможность добавлять какие-нибудь ключи которые не были определены изначально в интерфейсе, то можно добавить такую интересную штуку `[key:string]: unknown`.  Эта запись будет означать что может быть любой ключ, но с типоп string и не известное значение данного ключа
![[Pasted image 20230627195450.png]]


Объекты как параметры функций работают чуть по другом, чем интерфейсы. Если в интерфейсам в базовом написании если не в интерфейсе нет одного ключей, а в объекте к которому прикреплен данный интерфейс есть лишний ключ, то это будет ошибка. ==В таком же примере могут быть любое количество ключей не указанных изначально, но если не будет ключа который был указан будет ошибка==
```js
 function aa (points: {onekey: string, twokey: number}):void {
 
 };

const obj = {
	a: 'sdfsd',
	b: 1,
	z: boolean
}
 aa(obj);
```
![[obj-like-param-func.mp4]]

### Типизация массивов
Мы говорим что это массив строк
```js
let tt: string[] = []; // мы говорим что это массив строк
let ss: numberp[] = []; // говорим что это может быть только массив чисел
```

Чекать массив объектов
Вот вариант где мы задаем что должен быть массив в индексе которого должен находится объект и он доложен соответствовать интерфейсу Car
![[Pasted image 20230627212635.png]]


Валидаци масив масиивов

![[Pasted image 20230627213109.png]]

Если не через энтерфейсы а через функции указывать массивы то `unknown[]`  говорит что это должен быть массив и не важно что внутри
![[Pasted image 20230627213405.png]]

**Тупл, он же Кортеж**

В отличии от массивов кортежы склонны к тому что бы содержать разноненную  информацию.
Обычно картеджи ограниченны по размерам.


Массив пар
`[[key, value], [key, value]]`

Синтакскис для массива пар такой. Когда какие то типы оказались внути кватрадных скобок, то это значит картэжи

```
const data: [string,string][] = [[key, value], [key, value]];
```


### алиасы

```
type Pair = [string, string]
```

Вот пример массив  пар с помощью type
![[Pasted image 20230627220345.png]] 
тип примерно тоже самое что interface.
Различаются в синтаксисе    что используется знак =

#### Union
Это перечесление каких то значенией, но только из указанных значений может быть доступны. Узкие тип для каких то значений, с ограниченным их количеством
Значением переменной staticX может быть только одно из трех значений которые перечисленные в типе Status, другие значения быть не могут.
![[Pasted image 20230627221030.png]]

#### Enum



N.B.
Разница между any и unknown в том что, тип any нам всеравно какой это будет тип, а unknown значит что нам всеравно до поры до времени, что мы всеравно должны его определить в  дальнейшем
### Links
----------

### References
------------


### Zero-links
----
[[00 Typescript]]